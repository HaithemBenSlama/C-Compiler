Lexeme			Token			Line Number
extern			EXTERN			11
void			VOID			11
*			MULTIPLY			11
malloc			IDENTIFIER			11
(			LEFT_PAREN			11
int			INT			11
size			IDENTIFIER			11
)			RIGHT_PAREN			11
;			SEMICOLON			11
extern			EXTERN			13
void			VOID			13
free			IDENTIFIER			13
(			LEFT_PAREN			13
void			VOID			13
*			MULTIPLY			13
ptr			IDENTIFIER			13
)			RIGHT_PAREN			13
;			SEMICOLON			13
void			VOID			17
*			MULTIPLY			17
allouer			IDENTIFIER			17
(			LEFT_PAREN			17
void			VOID			17
*			MULTIPLY			17
p			IDENTIFIER			17
)			RIGHT_PAREN			17
{			LEFT_BRACE			17
if			IF			19
(			LEFT_PAREN			19
p			IDENTIFIER			19
==			EQUAL			19
0			CONSTANT			19
)			RIGHT_PAREN			19
goto			GOTO			19
Lelse1			IDENTIFIER			19
;			SEMICOLON			19
{			LEFT_BRACE			21
void			VOID			23
*			MULTIPLY			23
_t1			IDENTIFIER			23
;			SEMICOLON			23
void			VOID			25
*			MULTIPLY			25
_t2			IDENTIFIER			25
;			SEMICOLON			25
_t1			IDENTIFIER			27
=			ASSIGN			27
p			IDENTIFIER			27
+			PLUS			27
4			CONSTANT			27
;			SEMICOLON			27
_t2			IDENTIFIER			29
=			ASSIGN			29
malloc			IDENTIFIER			29
(			LEFT_PAREN			29
8			CONSTANT			29
)			RIGHT_PAREN			29
;			SEMICOLON			29
*			MULTIPLY			31
_t1			IDENTIFIER			31
=			ASSIGN			31
_t2			IDENTIFIER			31
;			SEMICOLON			31
return			RETURN			33
_t1			IDENTIFIER			33
;			SEMICOLON			33
}			RIGHT_BRACE			35
Lelse1			IDENTIFIER			37
:			COLON			37
{			LEFT_BRACE			39
p			IDENTIFIER			41
=			ASSIGN			41
malloc			IDENTIFIER			41
(			LEFT_PAREN			41
8			CONSTANT			41
)			RIGHT_PAREN			41
;			SEMICOLON			41
return			RETURN			43
p			IDENTIFIER			43
;			SEMICOLON			43
}			RIGHT_BRACE			45
}			RIGHT_BRACE			47
void			VOID			51
*			MULTIPLY			51
desallouer			IDENTIFIER			51
(			LEFT_PAREN			51
void			VOID			51
*			MULTIPLY			51
p			IDENTIFIER			51
)			RIGHT_PAREN			51
{			LEFT_BRACE			51
void			VOID			53
*			MULTIPLY			53
q			IDENTIFIER			53
;			SEMICOLON			53
void			VOID			55
*			MULTIPLY			55
_t1			IDENTIFIER			55
;			SEMICOLON			55
_t1			IDENTIFIER			57
=			ASSIGN			57
p			IDENTIFIER			57
+			PLUS			57
suivant			IDENTIFIER			57
;			SEMICOLON			57
q			IDENTIFIER			59
=			ASSIGN			59
*			MULTIPLY			59
_t1			IDENTIFIER			59
;			SEMICOLON			59
free			IDENTIFIER			61
(			LEFT_PAREN			61
p			IDENTIFIER			61
)			RIGHT_PAREN			61
;			SEMICOLON			61
return			RETURN			63
q			IDENTIFIER			63
;			SEMICOLON			63
}			RIGHT_BRACE			65
void			VOID			69
*			MULTIPLY			69
parcours			IDENTIFIER			69
(			LEFT_PAREN			69
void			VOID			69
*			MULTIPLY			69
l			IDENTIFIER			69
,			 COMMA 			69
void			VOID			69
*			MULTIPLY			69
f			IDENTIFIER			69
)			RIGHT_PAREN			69
{			LEFT_BRACE			69
int			INT			71
i			IDENTIFIER			71
;			SEMICOLON			71
void			VOID			73
*			MULTIPLY			73
p			IDENTIFIER			73
;			SEMICOLON			73
void			VOID			75
*			MULTIPLY			75
tete			IDENTIFIER			75
;			SEMICOLON			75
p			IDENTIFIER			77
=			ASSIGN			77
f			IDENTIFIER			77
(			LEFT_PAREN			77
l			IDENTIFIER			77
)			RIGHT_PAREN			77
;			SEMICOLON			77
tete			IDENTIFIER			79
=			ASSIGN			79
p			IDENTIFIER			79
;			SEMICOLON			79
i			IDENTIFIER			81
=			ASSIGN			81
0			CONSTANT			81
;			SEMICOLON			81
goto			GOTO			85
Ltest1			IDENTIFIER			85
;			SEMICOLON			85
Lfor1			IDENTIFIER			87
:			COLON			87
p			IDENTIFIER			89
=			ASSIGN			89
f			IDENTIFIER			89
(			LEFT_PAREN			89
p			IDENTIFIER			89
)			RIGHT_PAREN			89
;			SEMICOLON			89
i			IDENTIFIER			91
=			ASSIGN			91
i			IDENTIFIER			91
+			PLUS			91
1			CONSTANT			91
;			SEMICOLON			91
Ltest1			IDENTIFIER			93
:			COLON			93
if			IF			95
(			LEFT_PAREN			95
i			IDENTIFIER			95
<			LESS_THAN			95
100			CONSTANT			95
)			RIGHT_PAREN			95
goto			GOTO			95
Lfor1			IDENTIFIER			95
;			SEMICOLON			95
return			RETURN			97
tete			IDENTIFIER			97
;			SEMICOLON			97
}			RIGHT_BRACE			99
int			INT			103
main			IDENTIFIER			103
(			LEFT_PAREN			103
)			RIGHT_PAREN			103
{			LEFT_BRACE			103
void			VOID			105
*			MULTIPLY			105
tete			IDENTIFIER			105
;			SEMICOLON			105
void			VOID			107
*			MULTIPLY			107
_t1			IDENTIFIER			107
;			SEMICOLON			107
void			VOID			109
*			MULTIPLY			109
_t2			IDENTIFIER			109
;			SEMICOLON			109
_t1			IDENTIFIER			111
=			ASSIGN			111
&			ADDRESS			111
allouer			IDENTIFIER			111
;			SEMICOLON			111
_t2			IDENTIFIER			113
=			ASSIGN			113
&			ADDRESS			113
desallouer			IDENTIFIER			113
;			SEMICOLON			113
tete			IDENTIFIER			115
=			ASSIGN			115
parcours			IDENTIFIER			115
(			LEFT_PAREN			115
0			CONSTANT			115
,			 COMMA 			115
_t1			IDENTIFIER			115
)			RIGHT_PAREN			115
;			SEMICOLON			115
parcours			IDENTIFIER			117
(			LEFT_PAREN			117
tete			IDENTIFIER			117
,			 COMMA 			117
_t2			IDENTIFIER			117
)			RIGHT_PAREN			117
;			SEMICOLON			117
return			RETURN			119
1			CONSTANT			119
;			SEMICOLON			119
}			RIGHT_BRACE			121
