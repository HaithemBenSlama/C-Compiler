Lexeme			Token			Line Number
struct			STRUCT			13
liste			IDENTIFIER			13
{			LEFT_BRACE			13
int			INT			15
valeur			IDENTIFIER			15
;			SEMICOLON			15
struct			STRUCT			17
liste			IDENTIFIER			17
*			MULTIPLY			17
suivant			IDENTIFIER			17
;			SEMICOLON			17
}			RIGHT_BRACE			19
;			SEMICOLON			19
extern			EXTERN			23
void			VOID			23
*			MULTIPLY			23
malloc			IDENTIFIER			23
(			LEFT_PAREN			23
int			INT			23
size			IDENTIFIER			23
)			RIGHT_PAREN			23
;			SEMICOLON			23
extern			EXTERN			25
void			VOID			25
free			IDENTIFIER			25
(			LEFT_PAREN			25
void			VOID			25
*			MULTIPLY			25
ptr			IDENTIFIER			25
)			RIGHT_PAREN			25
;			SEMICOLON			25
struct			STRUCT			31
liste			IDENTIFIER			31
*			MULTIPLY			31
allouer			IDENTIFIER			31
(			LEFT_PAREN			31
struct			STRUCT			31
liste			IDENTIFIER			31
*			MULTIPLY			31
p			IDENTIFIER			31
)			RIGHT_PAREN			31
{			LEFT_BRACE			31
if			IF			33
(			LEFT_PAREN			33
p			IDENTIFIER			33
!=			NOT_EQUAL			33
0			CONSTANT			33
)			RIGHT_PAREN			33
{			LEFT_BRACE			33
p			IDENTIFIER			35
->			ARROW			35
suivant			IDENTIFIER			35
=			ASSIGN			35
malloc			IDENTIFIER			35
(			LEFT_PAREN			35
sizeof			SIZEOF			35
(			LEFT_PAREN			35
p			IDENTIFIER			35
)			RIGHT_PAREN			35
)			RIGHT_PAREN			35
;			SEMICOLON			35
return			RETURN			37
p			IDENTIFIER			37
->			ARROW			37
suivant			IDENTIFIER			37
;			SEMICOLON			37
}			RIGHT_BRACE			39
else			ELSE			39
{			LEFT_BRACE			39
p			IDENTIFIER			41
=			ASSIGN			41
malloc			IDENTIFIER			41
(			LEFT_PAREN			41
sizeof			SIZEOF			41
(			LEFT_PAREN			41
p			IDENTIFIER			41
)			RIGHT_PAREN			41
)			RIGHT_PAREN			41
;			SEMICOLON			41
return			RETURN			43
p			IDENTIFIER			43
;			SEMICOLON			43
}			RIGHT_BRACE			45
}			RIGHT_BRACE			47
struct			STRUCT			51
liste			IDENTIFIER			51
*			MULTIPLY			51
desallouer			IDENTIFIER			51
(			LEFT_PAREN			51
struct			STRUCT			51
liste			IDENTIFIER			51
*			MULTIPLY			51
p			IDENTIFIER			51
)			RIGHT_PAREN			51
{			LEFT_BRACE			51
struct			STRUCT			53
liste			IDENTIFIER			53
*			MULTIPLY			53
q			IDENTIFIER			53
;			SEMICOLON			53
q			IDENTIFIER			55
=			ASSIGN			55
p			IDENTIFIER			55
->			ARROW			55
suivant			IDENTIFIER			55
;			SEMICOLON			55
free			IDENTIFIER			57
(			LEFT_PAREN			57
p			IDENTIFIER			57
)			RIGHT_PAREN			57
;			SEMICOLON			57
return			RETURN			59
q			IDENTIFIER			59
;			SEMICOLON			59
}			RIGHT_BRACE			61
struct			STRUCT			65
liste			IDENTIFIER			65
*			MULTIPLY			65
parcours			IDENTIFIER			65
(			LEFT_PAREN			65
struct			STRUCT			65
liste			IDENTIFIER			65
*			MULTIPLY			65
l			IDENTIFIER			65
,			COMMA			65
struct			STRUCT			65
liste			IDENTIFIER			65
*			MULTIPLY			65
(			LEFT_PAREN			65
*			MULTIPLY			65
f			IDENTIFIER			65
)			RIGHT_PAREN			65
(			LEFT_PAREN			65
struct			STRUCT			65
liste			IDENTIFIER			65
*			MULTIPLY			65
p			IDENTIFIER			65
)			RIGHT_PAREN			65
)			RIGHT_PAREN			65
{			LEFT_BRACE			65
int			INT			67
i			IDENTIFIER			67
;			SEMICOLON			67
struct			STRUCT			69
liste			IDENTIFIER			69
*			MULTIPLY			69
p			IDENTIFIER			69
;			SEMICOLON			69
struct			STRUCT			71
liste			IDENTIFIER			71
*			MULTIPLY			71
tete			IDENTIFIER			71
;			SEMICOLON			71
tete			IDENTIFIER			73
=			ASSIGN			73
p			IDENTIFIER			73
=			ASSIGN			73
f			IDENTIFIER			73
(			LEFT_PAREN			73
l			IDENTIFIER			73
)			RIGHT_PAREN			73
;			SEMICOLON			73
for			FOR			75
(			LEFT_PAREN			75
i			IDENTIFIER			75
=			ASSIGN			75
0			CONSTANT			75
;			SEMICOLON			75
i			IDENTIFIER			75
<			LESS_THAN			75
100			CONSTANT			75
;			SEMICOLON			75
i			IDENTIFIER			75
=			ASSIGN			75
i			IDENTIFIER			75
+			PLUS			75
1			CONSTANT			75
)			RIGHT_PAREN			75
{			LEFT_BRACE			75
p			IDENTIFIER			77
=			ASSIGN			77
f			IDENTIFIER			77
(			LEFT_PAREN			77
p			IDENTIFIER			77
)			RIGHT_PAREN			77
;			SEMICOLON			77
}			RIGHT_BRACE			79
return			RETURN			81
tete			IDENTIFIER			81
;			SEMICOLON			81
}			RIGHT_BRACE			83
int			INT			87
main			IDENTIFIER			87
(			LEFT_PAREN			87
)			RIGHT_PAREN			87
{			LEFT_BRACE			87
struct			STRUCT			89
liste			IDENTIFIER			89
*			MULTIPLY			89
tete			IDENTIFIER			89
;			SEMICOLON			89
tete			IDENTIFIER			91
=			ASSIGN			91
parcours			IDENTIFIER			91
(			LEFT_PAREN			91
0			CONSTANT			91
,			COMMA			91
&			ADDRESS			91
allouer			IDENTIFIER			91
)			RIGHT_PAREN			91
;			SEMICOLON			91
parcours			IDENTIFIER			93
(			LEFT_PAREN			93
tete			IDENTIFIER			93
,			COMMA			93
&			ADDRESS			93
desallouer			IDENTIFIER			93
)			RIGHT_PAREN			93
;			SEMICOLON			93
return			RETURN			95
1			CONSTANT			95
;			SEMICOLON			95
}			RIGHT_BRACE			97
